# ============================================================================
# Docker Compose File Version
# ============================================================================
# version: Docker Compose 파일 형식 버전을 지정합니다.
# '3.3'은 Docker Compose 버전 3.3 형식을 사용합니다.
# 이 버전은 Docker Engine 17.06.0 이상에서 지원됩니다.
# 최신 기능과 호환성을 위해 적절한 버전을 선택하는 것이 중요합니다.
version: '3.3'

# ============================================================================
# Services Definition
# ============================================================================
# services: 이 섹션에서 실행할 컨테이너 서비스들을 정의합니다.
# 각 서비스는 독립적인 컨테이너로 실행되며, 서로 통신할 수 있습니다.
services:
  # geth: Ethereum Geth 노드 서비스 이름
  # 이 이름은 docker-compose 명령어에서 서비스를 참조할 때 사용됩니다.
  # 예: docker-compose logs geth
  geth:
    # ========================================================================
    # Build Configuration
    # ========================================================================
    # build: Docker 이미지를 빌드하는 방법을 지정합니다.
    # 이미지를 미리 빌드하지 않고 docker-compose up 시 자동으로 빌드합니다.
    build:
      # context: Docker 빌드 컨텍스트 경로
      # '.'는 현재 디렉토리(docker-compose.yml이 있는 위치)를 의미합니다.
      # Dockerfile과 필요한 파일들이 이 경로에 있어야 합니다.
      context: .
      # dockerfile: 사용할 Dockerfile 이름
      # 기본값은 'Dockerfile'이지만, 다른 이름을 사용할 수 있습니다.
      # 예: dockerfile: Dockerfile.production
      dockerfile: Dockerfile

    # ========================================================================
    # Container Configuration
    # ========================================================================
    # container_name: 컨테이너에 부여할 이름
    # 지정하지 않으면 '프로젝트명-서비스명-번호' 형식으로 자동 생성됩니다.
    # 고정된 이름을 사용하면 컨테이너를 쉽게 참조할 수 있습니다.
    # 예: docker logs ethereum-node
    container_name: ethereum-node

    # restart: 컨테이너 재시작 정책
    # unless-stopped: 컨테이너가 명시적으로 중지되지 않는 한 자동으로 재시작합니다.
    #   - Docker 데몬이 시작될 때 자동으로 컨테이너를 시작합니다.
    #   - 컨테이너가 크래시되면 자동으로 재시작합니다.
    #   - docker-compose stop으로 중지한 경우에는 재시작하지 않습니다.
    # 다른 옵션: no, always, on-failure
    restart: unless-stopped

    # ========================================================================
    # Port Mapping
    # ========================================================================
    # ports: 호스트와 컨테이너 간의 포트 매핑을 정의합니다.
    # 형식: "호스트포트:컨테이너포트" 또는 "호스트IP:호스트포트:컨테이너포트"
    ports:
      # P2P 네트워크 포트 (TCP)
      # "30303:30303/tcp": 호스트의 30303 포트를 컨테이너의 30303 포트에 매핑 (TCP)
      #   - 호스트의 모든 네트워크 인터페이스(0.0.0.0)에서 접근 가능
      #   - 다른 Ethereum 노드들이 이 포트로 연결할 수 있습니다.
      #   - 방화벽에서 이 포트를 열어야 인바운드 연결을 받을 수 있습니다.
      - "30303:30303/tcp"
      # P2P 네트워크 포트 (UDP)
      # "30303:30303/udp": 호스트의 30303 포트를 컨테이너의 30303 포트에 매핑 (UDP)
      #   - P2P 네트워크 통신에 UDP도 사용됩니다.
      - "30303:30303/udp"
      # HTTP-RPC 포트 (로컬호스트만 노출)
      # "127.0.0.1:8545:8545": 호스트의 localhost(127.0.0.1) 8545 포트만 컨테이너의 8545 포트에 매핑
      #   - 127.0.0.1을 지정하면 localhost에서만 접근 가능합니다.
      #   - 외부 네트워크에서는 이 포트에 접근할 수 없어 보안이 강화됩니다.
      #   - RPC는 인증이 필요하지만, 추가 보안을 위해 localhost로 제한하는 것이 좋습니다.
      - "127.0.0.1:8545:8545"
      # WebSocket-RPC 포트 (로컬호스트만 노출)
      # "127.0.0.1:8546:8546": 호스트의 localhost(127.0.0.1) 8546 포트만 컨테이너의 8546 포트에 매핑
      #   - WebSocket은 실시간 구독(새 블록, 대기 중인 트랜잭션 등)에 사용됩니다.
      #   - localhost로 제한하여 보안을 강화합니다.
      - "127.0.0.1:8546:8546"

    # ========================================================================
    # Volume Mounts
    # ========================================================================
    # volumes: 호스트와 컨테이너 간의 디렉토리/파일 마운트를 정의합니다.
    # 컨테이너가 삭제되어도 데이터가 유지되도록 합니다.
    volumes:
      # 블록체인 데이터 영구 저장 (바인드 마운트)
      # /mnt/cryptocur-data/ethereum:/home/ethereum/.ethereum: 호스트의 특정 경로를 컨테이너 경로에 직접 마운트
      #   - /mnt/cryptocur-data/ethereum: 호스트의 절대 경로 (블록체인 데이터가 저장될 위치)
      #   - /home/ethereum/.ethereum: 컨테이너 내부의 Geth 데이터 디렉토리
      #   - 이 경로에는 블록체인 데이터(수백 GB), 지갑 파일, 설정 파일 등이 저장됩니다.
      #   - 컨테이너를 재생성해도 데이터가 유지됩니다.
      # 중요: 디렉토리가 존재하고 적절한 권한이 설정되어 있어야 합니다.
      #   실행 전에 다음 명령어를 실행하세요:
      #   sudo mkdir -p /mnt/cryptocur-data/ethereum
      #   ETHEREUM_UID=$(docker run --rm docker_geth id -u ethereum) && sudo chown -R $ETHEREUM_UID:$ETHEREUM_UID /mnt/cryptocur-data/ethereum
      - /mnt/cryptocur-data/ethereum:/home/ethereum/.ethereum
      # 설정 파일 마운트 (선택사항, 파일이 존재하는 경우에만)
      # ./geth.toml:/home/ethereum/.ethereum/geth.toml:ro
      #   - ./geth.toml: 호스트의 현재 디렉토리에 있는 geth.toml 파일
      #   - :ro: 읽기 전용(read-only)으로 마운트
      #     컨테이너 내부에서 설정 파일을 수정할 수 없습니다.
      #   - 이 파일이 없어도 컨테이너는 정상적으로 시작됩니다 (선택사항).
      #   - 설정 파일이 마운트되면 Geth가 자동으로 이를 읽어 사용합니다.
      #   - 설정을 변경하려면 호스트의 geth.toml 파일을 편집하고 컨테이너를 재시작합니다.
      - ./geth.toml:/home/ethereum/.ethereum/geth.toml:ro

    # ========================================================================
    # Environment Variables
    # ========================================================================
    # environment: 컨테이너 내부에서 사용할 환경 변수를 설정합니다.
    # ${VARIABLE:-default}: 환경 변수가 설정되지 않으면 기본값을 사용합니다.
    # 호스트의 환경 변수나 .env 파일에서 값을 가져올 수 있습니다.
    environment:
      # 네트워크 설정
      # ETHEREUM_NETWORK: 사용할 Ethereum 네트워크
      # ${ETHEREUM_NETWORK:-mainnet}: 환경 변수가 없으면 'mainnet'을 기본값으로 사용
      # .env 파일이나 호스트 환경 변수로 설정할 수 있습니다.
      # 가능한 값: mainnet, goerli, sepolia
      ETHEREUM_NETWORK: ${ETHEREUM_NETWORK:-mainnet}

    # ========================================================================
    # Command Override
    # ========================================================================
    # command: Dockerfile의 CMD를 오버라이드하여 다른 명령어를 실행합니다.
    # Geth의 명령줄 옵션을 직접 지정할 수 있습니다.
    command:
      # geth 실행 파일 (필수)
      # Docker는 첫 번째 항목을 실행 파일로 인식하므로 반드시 'geth'를 첫 번째로 지정해야 합니다.
      # 이 항목이 없으면 "executable file not found" 에러가 발생할 수 있습니다.
      - geth
      # 기본 옵션
      # --config: 설정 파일 경로
      #   geth.toml 파일이 마운트된 경우 이 파일을 사용합니다.
      - --config=/home/ethereum/.ethereum/geth.toml
      # 설정 파일이 없으면 아래 명령줄 옵션 사용
      # --mainnet: 메인넷 네트워크 사용
      #   다른 네트워크: --goerli, --sepolia
      - --mainnet
      # --datadir: 데이터 디렉토리 경로
      - --datadir=/home/ethereum/.ethereum
      # --http: HTTP-RPC 서버 활성화
      #   JSON-RPC API를 HTTP를 통해 제공합니다.
      - --http
      # --http.addr: HTTP-RPC 서버 바인딩 주소
      #   0.0.0.0은 모든 네트워크 인터페이스에 바인딩하지만,
      #   포트 매핑에서 127.0.0.1로 제한했으므로 호스트에서는 localhost만 접근 가능합니다.
      - --http.addr=0.0.0.0
      # --http.port: HTTP-RPC 서버 포트
      - --http.port=8545
      # --http.api: 허용할 HTTP-RPC API 목록
      #   eth, net, web3: 기본 API
      #   admin, debug: 관리 및 디버깅 API (보안 주의)
      - --http.api=eth,net,web3,admin,debug
      # --http.corsdomain: CORS 허용 도메인
      #   "*"는 모든 도메인을 허용합니다 (개발용, 보안 주의).
      - --http.corsdomain=*
      # --http.vhosts: 가상 호스트
      #   "*"는 모든 호스트를 허용합니다.
      - --http.vhosts=*
      # --ws: WebSocket-RPC 서버 활성화
      #   실시간 구독(새 블록, 대기 중인 트랜잭션 등)에 필요합니다.
      - --ws
      # --ws.addr: WebSocket-RPC 서버 바인딩 주소
      - --ws.addr=0.0.0.0
      # --ws.port: WebSocket-RPC 서버 포트
      - --ws.port=8546
      # --ws.api: 허용할 WebSocket-RPC API 목록
      - --ws.api=eth,net,web3,admin,debug
      # --ws.origins: WebSocket Origin 허용
      #   "*"는 모든 Origin을 허용합니다 (개발용, 보안 주의).
      - --ws.origins=*
      # --syncmode: 동기화 모드
      #   snap: 빠른 동기화 (권장)
      #   full: 전체 동기화 (느리지만 완전함)
      #   light: 경량 동기화 (제한적 기능)
      - --syncmode=snap
      # --cache: 캐시 크기 (MB)
      #   동기화 속도와 쿼리 성능을 향상시킵니다.
      #   더 높은 값(예: 8192)은 더 빠른 성능을 제공하지만 더 많은 RAM이 필요합니다.
      #   시스템의 사용 가능한 메모리에 맞게 조정하세요.
      - --cache=4096
      # --maxpeers: 최대 피어 연결 수
      #   더 높은 값은 더 많은 피어를 허용하지만 대역폭과 리소스를 더 많이 소비합니다.
      - --maxpeers=50

    # ========================================================================
    # Network Configuration
    # ========================================================================
    # networks: 컨테이너가 연결될 Docker 네트워크를 지정합니다.
    # 여러 서비스가 같은 네트워크에 있으면 서비스 이름으로 서로 통신할 수 있습니다.
    networks:
      # ethereum-network: 아래 networks 섹션에서 정의된 네트워크
      # 이 네트워크에 연결된 다른 컨테이너들과 통신할 수 있습니다.
      - ethereum-network

    # ========================================================================
    # Resource Limits (Optional)
    # ========================================================================
    # deploy: Docker Swarm 모드에서 주로 사용되지만, docker-compose에서는 제한적으로 지원됩니다.
    # 주의: 'deploy' 섹션의 리소스 제한은 Docker Swarm 모드에서만 작동합니다.
    # docker-compose를 사용하는 경우 리소스 제한을 설정하려면 'docker update' 명령어를 사용해야 합니다.
    # 리소스 제한 (선택사항, Docker Swarm 모드에서만 작동)
    # deploy:
    #   resources:
    #     # limits: 컨테이너가 사용할 수 있는 최대 리소스
    #     # 이 값을 초과하면 컨테이너가 제한됩니다.
    #     limits:
    #       # cpus: 최대 CPU 코어 수
    #       # '8'은 8개의 CPU 코어를 의미합니다.
    #       # Geth는 CPU 집약적이므로 충분한 CPU를 할당하는 것이 좋습니다.
    #       cpus: '8'
    #       # memory: 최대 메모리 사용량
    #       # 16G는 16GB의 메모리를 의미합니다.
    #       # cache 설정과 함께 고려하여 충분한 메모리를 할당해야 합니다.
    #       memory: 16G
    #     # reservations: 컨테이너에 보장할 최소 리소스
    #     # 시스템이 이만큼의 리소스를 항상 할당하려고 시도합니다.
    #     reservations:
    #       # cpus: 보장할 최소 CPU 코어 수
    #       # '4'는 최소 4개의 CPU 코어를 보장합니다.
    #       cpus: '4'
    #       # memory: 보장할 최소 메모리
    #       # 8G는 최소 8GB의 메모리를 보장합니다.
    #       # cache=4096MB와 함께 고려하여 적절한 값을 설정합니다.
    #       memory: 8G

# ============================================================================
# Volumes Definition
# ============================================================================
# volumes: 데이터 영구 저장을 위한 볼륨을 정의합니다.
# 현재는 바인드 마운트를 사용하므로 이 섹션은 주석 처리되어 있습니다.
# 명명된 볼륨(named volume)을 사용하려면 아래 주석을 해제하고 volumes 섹션을 수정하세요.
# volumes:
#   ethereum-data:
#     # 바인드 마운트를 사용하여 /mnt/cryptocur-data/ethereum에 데이터 저장
#     # 데이터는 호스트의 /mnt/cryptocur-data/ethereum 디렉토리에 저장됩니다
#     # 시작하기 전에 디렉토리가 존재하고 적절한 권한이 설정되어 있는지 확인하세요

# ============================================================================
# Networks Definition
# ============================================================================
# networks: 컨테이너 간 통신을 위한 네트워크를 정의합니다.
# 같은 네트워크에 있는 컨테이너들은 서비스 이름으로 서로 통신할 수 있습니다.
networks:
  # ethereum-network: 네트워크 이름
  # 이 이름으로 위의 services 섹션에서 참조됩니다.
  ethereum-network:
    # driver: 네트워크 드라이버
    # bridge: 기본 브리지 네트워크 드라이버
    #   - 같은 호스트의 컨테이너들이 서로 통신할 수 있습니다.
    #   - 외부 네트워크와의 통신은 포트 매핑을 통해 이루어집니다.
    driver: bridge
